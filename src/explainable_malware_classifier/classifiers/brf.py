from timeit import default_timer as timer
from typing import Any

import pandas as pd
from imblearn.ensemble import BalancedRandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import classification_report
from sklearn.model_selection import train_test_split, StratifiedKFold, cross_val_score
from sklearn.preprocessing import LabelEncoder
import joblib

from explainable_malware_classifier.classifiers import load_dataset
from explainable_malware_classifier.classifiers.base import BaseMalwareClassifier
from explainable_malware_classifier.classifiers.utils import comma_tokenizer


# Cross-Validation f1_macro scores: [0.756897   0.7440342  0.77175314 0.74416155 0.74272462 0.76479913
#  0.74726337 0.76181076 0.75193105 0.70505926]
# Cross-Validation f1_macro mean:  0.7490434089624188
# Cross-Validation f1_macro std:   0.017388568023043244
# --------------------------------------------------
# Classification Report:
#                precision    recall  f1-score   support
#
#       adware       0.89      0.62      0.73       282
#     backdoor       0.91      0.71      0.80       352
#   downloader       0.83      0.75      0.79       231
#      dropper       0.52      0.73      0.61       173
#      spyware       0.47      0.64      0.54       172
#       trojan       0.89      0.99      0.94      2883
#        virus       0.99      0.88      0.93      1076
#        worms       0.83      0.53      0.65       399
#
#     accuracy                           0.87      5568
#    macro avg       0.79      0.73      0.75      5568
# weighted avg       0.88      0.87      0.87      5568
#
# --------------------------------------------------
# Total Runtime(s): 754.39


class MalwareClassifierBRF(BaseMalwareClassifier):
    def __init__(
        self,
        n_estimators=500,
        replacement=True,
        bootstrap=False,
        sampling_strategy="not majority",
        random_state=69,
        verbose=1,
        n_jobs=-1,
    ):
        """
        Initialize the classifier with desired hyperparameters.
        Also sets up a TfidfVectorizer and LabelEncoder.
        """
        self.random_state = random_state
        self.vectorizer = TfidfVectorizer(
            tokenizer=comma_tokenizer,
            token_pattern=None,
            max_features=20_000,
            ngram_range=(1, 2),
        )
        self.label_encoder = LabelEncoder()
        self.classifier = BalancedRandomForestClassifier(
            n_estimators=n_estimators,
            replacement=replacement,
            bootstrap=bootstrap,
            sampling_strategy=sampling_strategy,
            random_state=self.random_state,
            verbose=verbose,
            n_jobs=n_jobs,
        )

    def load_and_transform_data(
        self, dataset_name: str
    ) -> tuple[pd.DataFrame, pd.DataFrame]:
        """
        Loads data from a CSV file, transforms it via TF-IDF,
        encodes labels, and returns (X, y) arrays.
        """
        df = load_dataset(dataset_name)
        X = self.vectorizer.fit_transform(df["api"])
        y_encoded = self.label_encoder.fit_transform(df["class"])
        return X, y_encoded

    def cross_validate(
        self,
        X: pd.DataFrame,
        y: pd.DataFrame,
        cv_splits: int = 10,
        scoring: str = "f1_macro",
    ) -> None:
        """
        Performs Stratified K-Fold cross-validation and prints the scores.
        """
        kfold = StratifiedKFold(
            n_splits=cv_splits, shuffle=True, random_state=self.random_state
        )
        cv_scores = cross_val_score(
            self.classifier, X, y, cv=kfold, scoring=scoring, verbose=1, n_jobs=-1
        )
        print(f"Cross-Validation {scoring} scores:", cv_scores)
        print(f"Cross-Validation {scoring} mean:  {cv_scores.mean()}")
        print(f"Cross-Validation {scoring} std:   {cv_scores.std()}")
        print("-" * 50)

    def train_and_evaluate(
        self, X: pd.DataFrame, y: pd.DataFrame, test_size: float = 0.2
    ) -> None:
        """
        Splits data into train/test, fits the classifier on training set,
        predicts on the test set, decodes the labels, and prints a classification report.
        """
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=test_size, random_state=self.random_state
        )
        self.classifier.fit(X_train, y_train)
        y_pred_encoded = self.classifier.predict(X_test)
        y_pred = self.label_encoder.inverse_transform(y_pred_encoded)
        y_test_decoded = self.label_encoder.inverse_transform(y_test)
        print("Classification Report:\n", classification_report(y_test_decoded, y_pred))
        self.plot_confusion_matrix(
            y_test_decoded,
            y_pred,
            title="BRF Confusion Matrix",
            save_as="brf_conf_matrix.png",
        )
        print("-" * 50)

    def save_model(self, filename: str) -> None:
        """
        Saves the classifier, TF-IDF vectorizer, and label encoder to a file.
        """
        joblib.dump((self.classifier, self.vectorizer, self.label_encoder), filename)
        print(f"Model artifacts have been saved to: {filename}")

    @staticmethod
    def load_model(filename: str) -> tuple[Any, Any, Any]:
        """
        Loads the classifier, TF-IDF vectorizer, and label encoder from a file.
        Returns them as a tuple (classifier, vectorizer, label_encoder).
        """
        classifier, vectorizer, label_encoder = joblib.load(filename)
        return classifier, vectorizer, label_encoder

    def run(self) -> None:
        start_time = timer()
        X, y = self.load_and_transform_data("preprocessed_merged_seq.csv")
        self.cross_validate(X, y, cv_splits=10, scoring="f1_macro")
        self.train_and_evaluate(X, y)
        self.save_model("brf_model.pkl")
        print("Total Runtime(s):", round(timer() - start_time, 2))
