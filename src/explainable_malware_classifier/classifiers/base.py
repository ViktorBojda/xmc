import os
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Any

import joblib
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from scipy.sparse import csc_matrix
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.preprocessing import LabelEncoder

from explainable_malware_classifier.classifiers import save_plot
from explainable_malware_classifier.classifiers.utils import load_dataset
from explainable_malware_classifier.settings import PLOTS_DIR, MODELS_DIR_PATH
from explainable_malware_classifier.utils import prompt_overwrite


class BaseMalwareClassifier(ABC):
    DATASET_NAME = "preprocessed_merged_seq.csv"
    label_encoder: LabelEncoder
    vectorizer: TfidfVectorizer

    @property
    @abstractmethod
    def model_name(self): ...

    @classmethod
    def model_path(cls) -> Path:
        return MODELS_DIR_PATH / cls.model_name

    def plot_confusion_matrix(
        self, y_true: pd.Series, y_pred: pd.Series, *, title: str, save_as: str
    ) -> None:
        classes = self.label_encoder.classes_
        cm = confusion_matrix(y_true, y_pred, labels=classes, normalize="true")
        _, ax = plt.subplots(figsize=(5, 5))
        disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=classes)
        disp.plot(ax=ax, values_format=".2f")
        plt.xticks(rotation=45)
        save_plot(title=title, save_as=save_as)

    @staticmethod
    def display_cv_results(scoring: str, scores: list[float]) -> None:
        print(f"Cross-Validation {scoring} scores:", [round(s, 4) for s in scores])
        print(f"Cross-Validation {scoring} mean:   {np.mean(scores):.4f}")
        print(f"Cross-Validation {scoring} std:    {np.std(scores, ddof=1):.4f}")
        print("-" * 50)

    @staticmethod
    def comma_tokenizer(text: str) -> list[str]:
        return text.split(",")

    def load_and_transform_data(self) -> tuple[csc_matrix, np.ndarray]:
        df = load_dataset(self.DATASET_NAME)
        X = csc_matrix(self.vectorizer.fit_transform(df["api"]))
        y = self.label_encoder.fit_transform(df["class"])
        return X, y

    @abstractmethod
    def cross_validate(self, X, y, *, cv_splits, scoring): ...

    @abstractmethod
    def train_and_evaluate(self, X, y, *, test_size): ...

    def get_model_artifacts(self) -> dict[str, Any]:
        feature_names = list(self.vectorizer.get_feature_names_out())
        artifacts = {
            "vectorizer": self.vectorizer,
            "label_encoder": self.label_encoder,
            "feature_names": feature_names,
        }
        return artifacts

    def save_model_artifacts(
        self,
        X_train: np.ndarray,
        X_test: np.ndarray,
        y_train: np.ndarray,
        y_test: np.ndarray,
    ) -> None:
        model_path = self.model_path()
        if not prompt_overwrite(model_path):
            return
        artifacts = self.get_model_artifacts()
        artifacts.update(
            {"X_train": X_train, "X_test": X_test, "y_train": y_train, "y_test": y_test}
        )
        joblib.dump(artifacts, filename=model_path, protocol=5)
        print(f"Model artifacts have been saved to: {model_path}")

    @classmethod
    def load_model_artifacts(cls) -> dict[str, Any]:
        return joblib.load(cls.model_path())

    @abstractmethod
    def run(self): ...
